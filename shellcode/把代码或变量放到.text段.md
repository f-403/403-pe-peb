
# 如何将函数和变量放入 `.text` 段（代码段）

本教程系统讲解如何将变量或函数显式放入 PE 文件的 `.text` 段（代码段），适用于 Shellcode 构造、手动加载器、驱动开发等场景。

---

## 📚 目录

1. [为什么要这么做](#1-为什么要这么做)
2. [将函数放入 `.text` 段](#2-将函数放入-text-段)
    - 2.1 [`__declspec(code_seg)`](#21-__declspeccode_seg)
    - 2.2 [`#pragma code_seg`](#22-pragma-code_seg)
    - 2.3 [正确关闭与包围规则](#23-正确关闭与包围规则)
3. [将变量放入 `.text` 段](#3-将变量放入-text-段)
    - 3.1 [`__declspec(allocate)` - MSVC](#31-__declspecallocate---msvc)
    - 3.2 [`__attribute__((section))` - GCC/Clang](#32-__attributesection---gccclang)
4. [混合数据和函数示例](#4-混合数据和函数示例)
5. [构造纯 `.text` 段的可执行文件](#5-构造纯-text-段的可执行文件)
6. [验证是否进入 `.text` 段](#6-验证是否进入-text-段)
7. [参考资料](#7-参考资料)

---

## 1. 为什么要这么做

- 构造无 `.data`/`.rdata` 的 Shellcode
- 提高代码混淆性（反逆向）
- 某些 Bootloader/驱动需要段结构极简
- 统一放置自定义段便于手动加载或内存执行

---

## 2. 将函数放入 `.text` 段

### 2.1 `__declspec(code_seg)`

```cpp
__declspec(code_seg(".text$mysub")) void MyFunction() {
    // 这个函数会进入 .text$mysub 段
}
```

- 适用于 MSVC 编译器。
- 注意：不影响之后的其他函数。

---

### 2.2 `#pragma code_seg`

这是全局方式，用于**批量控制多个函数**进入同一段：

```cpp
#pragma code_seg(".text$myblock")

void FuncA() {
    // 会进入 .text$myblock
}

void FuncB() {
    // 也会进入 .text$myblock
}

#pragma code_seg()  // 恢复默认段（即 .text）
```

---

### 2.3 正确关闭与包围规则

推荐使用 `push/pop` 方式：

```cpp
#pragma code_seg(push, myseg, ".text$group1")

void Func1() {
    // 进入 .text$group1
}

void Func2() {
    // 也进入 .text$group1
}

#pragma code_seg(pop, myseg)  // 恢复段设置
```

> ✅ **只能包围函数定义，不能包围语句或代码块！**
>
> ❌ 不允许：
> ```cpp
> #pragma code_seg(".text$bad")
> int a = 123; // 不会生效
> if (a) { ... } // 不受影响
> ```

---

## 3. 将变量放入 `.text` 段

### 3.1 `__declspec(allocate)` — 仅适用于 MSVC

```cpp
__declspec(allocate(".text")) const char data[] = "Hello in text";
```

- 强制变量进入 `.text` 段。
- ⚠️ 注意 `.text` 默认不可写，如需修改必须修改段属性。

---

### 3.2 `__attribute__((section))` — GCC/Clang 风格

```cpp
const char data[] __attribute__((section(".text"))) = "Inline data";
```

- 在类 Unix 系统或使用 MinGW、Clang 编译器时使用。
- 也可用于结构体、全局变量等。

---

## 4. 混合数据和函数示例

```cpp
#include <windows.h>

__declspec(allocate(".text")) const char mydata[] = "Data in text";

#pragma code_seg(push, myseg, ".text$code")

void Show() {
    MessageBoxA(NULL, mydata, "Msg", MB_OK);
}

#pragma code_seg(pop, myseg)

int main() {
    Show();
    return 0;
}
```

---

## 5. 构造纯 `.text` 段的可执行文件

可用于构建无 `.data` 的 Shellcode 或驱动。

### 链接器参数（MSVC）：

```
/MERGE:.rdata=.text /MERGE:.data=.text /SECTION:.text,EWR
```

> 将所有数据段合并进 `.text`，并设置其为 可执行/可写/可读。

### `.def` 文件写法：

```def
SECTIONS
{
    .text READ WRITE EXECUTE
}
```

---

## 6. 验证是否进入 `.text` 段

### 方法 1：`dumpbin`

```sh
dumpbin /ALL yourfile.exe > out.txt
```

- 查找 `.text` 段内容是否包含你的变量或函数地址。

### 方法 2：PE 工具（如 CFF Explorer / PEView / IDA）

- 检查 `.text` 段是否包含变量或字符串。
- 查看函数/符号的实际段落。

---

## 7. 参考资料

- [MSVC 官方文档：`__declspec(allocate)`](https://learn.microsoft.com/en-us/cpp/cpp/declspec-specifiers)
- [GCC 属性文档：`__attribute__((section))`](https://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Variable-Attributes.html)
- 《Windows PE 权威指南》
- IDA Pro/PEView 教程：查看段结构与重定位
```

---

