# 1. JMP 100， 这里的100是代表偏移量吗
是的，不过要具体分情况解释一下：

---

### ✅ 一般来说，`JMP 100` 中的 **`100` 代表的是“目标地址”**，**并不是偏移量本身**，但到底是偏移量还是绝对地址，要根据汇编语言的上下文环境来判断：

---

## 📘 情况一：**汇编源码层面（如 MASM/NASM）**

```asm
JMP 100
```

这个通常表示 **跳转到地址 `0x100`**，也就是绝对地址跳转（**不是偏移量**）。

* 相当于机器码的 **`E9` 指令 + 32位偏移（相对于下一条指令的偏移）**。
* 编译器会自动计算从当前位置跳到 `0x100` 所需的偏移量。

---

## 📙 情况二：**机器码层面**

如果你反汇编看到：

```
E9 78 56 34 12
```

* `E9` 是 **JMP rel32**，它后面的 `0x12345678` 是 **相对于下一条指令的偏移量**。
* 所以，这种情况下 `JMP` 后面的是 **偏移量**（以当前EIP为参考点的相对偏移）。

---

## 📕 情况三：**JMP 寄存器 / JMP 内存地址（间接跳转）**

比如：

```asm
JMP DWORD PTR [EBX]
JMP EAX
```

这些不是偏移量，而是：

* 寄存器跳转（绝对地址），或者
* 从内存中取出一个绝对地址进行跳转。

---

### 🧠 总结表：

| 形式             | 含义                  |
| -------------- | ------------------- |
| `JMP 100`      | 跳转到地址 0x100（绝对地址）   |
| `JMP SHORT +5` | 跳转到当前地址 +5（偏移量）     |
| `JMP rel32`    | 指令中存的是偏移量（机器码层）     |
| `JMP EAX`      | 跳转到 EAX 指向的地址（间接跳转） |
| `JMP [addr]`   | 跳转到内存中地址所指的值        |

---
# 2.那有些人说的， jmp计算方式时， 用人才以E8/E9+5什么的,是什么意思？
你说得非常好，确实有些人会说 “`JMP` 的偏移量是 `E9` 后跟一个偏移值”，或者讲“偏移是当前地址 + 5 + 相对偏移值”。
这里我们就来**完全拆解这套说法**，你就能明白“`E8+5`”到底怎么回事了。

---

## 🧩 一、指令格式本质（E8 / E9）

### 1. `E9` 和 `E8` 指令

| 指令   | 含义           | 后面跟的          |
| ---- | ------------ | ------------- |
| `E8` | `CALL rel32` | **相对偏移（4字节）** |
| `E9` | `JMP rel32`  | **相对偏移（4字节）** |

👉 所以：

* `E9 xx xx xx xx` 表示：跳转到 **当前地址 + 5 + 相对偏移** 的地方

  > “+5” 是因为整个 `JMP` 指令本身占了 5 字节（1 字节 `E9` + 4 字节偏移）

* 同理：`E8` 是 `CALL`，语义一样，只是有函数调用的返回机制。

---

## 🧠 二、偏移计算方式详解（例子）

### 示例：

当前地址为 `0x401000`，你写了一条机器码：

```
E9 0B 00 00 00
```

* `E9` 是 JMP 指令
* 后面 `0x0B` 是偏移量（相对于下一条指令）
* JMP 实际跳转到：

  ```
  0x401000（当前位置）
  ```

- 5          （指令长度）
- 0x0B       （偏移）
  \= 0x401010

  ```
  ```

### 所以总结：

```c
JMP目标地址 = 当前地址 + 5 + 偏移值
```

也就是：

```
跳转地址 = 下一条指令地址 + 相对偏移
```

---

## 🧪 三、如何反推偏移？

如果你想从某地址跳转到目标地址，偏移怎么写？

```c
offset = 目标地址 - (当前地址 + 5)
```

---

## ✅ 四、为什么有人说“E8 + 5”？

这其实是简化的说法，意思是：

* `E8` 是 `CALL`
* `E8` 或 `E9` 都带一个 4 字节偏移
* 这个偏移是以“下一条指令地址”为参考点来跳的

“+5” 就是指整个指令长 5 字节。
所以不管是 `E8` 还是 `E9`，你都要跳过 5 字节，才能精确对上目标。

---

## 🔚 总结

| 说法        | 实质                     |
| --------- | ---------------------- |
| JMP 100   | 通常是跳到绝对地址 0x100（源码层）   |
| JMP E9+偏移 | E9 后跟相对偏移（机器码层）        |
| “+5” 的说法  | 是指 JMP/CALL 本身长度 5 字节  |
| 偏移计算公式    | `偏移 = 目标地址 - 当前地址 - 5` |

---

🛠 如果你有一段代码或 Shellcode，我们也可以反推它的 JMP 跳转目标，或者我可以帮你写一个自动算偏移的小脚本。

# 3. 那VS看到的jmp, 是绝对地址还是偏移， 汇编中不能直接写绝对地址吧？
你这个问题问得非常关键，而且很专业！我们来详细解答：

---

## ✅ 总结性回答：

| 你在哪看到 `JMP`？    | 它是什么    | `JMP`后面是？                   | 能否写绝对地址？                               |
| --------------- | ------- | --------------------------- | -------------------------------------- |
| 🔧 **VS反汇编窗口**  | 机器码的反汇编 | 显示的是**目标地址（虚拟地址）**，但实质是相对偏移 | ❌ 汇编中不能直接写绝对地址跳转（除了一些伪指令）              |
| ✍️ **你自己写汇编代码** | 汇编源码    | `JMP target` 是标签，编译器自动计算偏移  | ✅ 但写成 `JMP 0x401000` 会出错（必须手动用指令伪操作实现） |

---

## 🧩 一、VS 反汇编窗口里看到的 `JMP`

在 VS 调试时，你会看到如下反汇编代码：

```asm
401000  E9 0B000000      JMP 0x401010
```

你看到的是“**反汇编结果**”，`E9 0B 00 00 00` 实际含义是：

* `E9` 是机器码指令 `JMP rel32`
* `0B 00 00 00` 是 **偏移值 = 0x0B**
* `401000 + 5 + 0x0B = 401010`

📌 所以：**机器里保存的是“相对偏移”，但 VS 反汇编工具已经帮你换算成了绝对地址显示。**

---

## 🧠 二、汇编语言中能否写 `JMP 0x401000`？

在 **MASM/NASM 等汇编语言中**，写法分两类：

### ✅ 正确写法：使用标签（推荐）

```asm
start:
    ; ...
    JMP start  ; 编译器自动计算偏移
```

* 这是最常见、最安全的写法。
* 编译器会自动算好偏移生成机器码。

---

### ❌ 不推荐写法：直接写绝对地址

```asm
JMP 0x401000  ; ✖️ 这通常编译不过
```

* `JMP` 是跳转指令，它在 Intel 指令集中没有 `JMP 绝对地址` 的立即数版本（opcode 不支持）。
* 如果你真的想跳转到某绝对地址，要写：

```asm
MOV EAX, 0x401000
JMP EAX
```

或者

```asm
JMP DWORD PTR [addr]
```

---

## 🛠 三、如果你真的要写绝对跳转怎么办？

必须手动构造机器码：

```asm
db 0xE9
dd 0x????????
```

这里 `dd` 那个数要你自己计算偏移：`目标地址 - 当前地址 - 5`

例如：

```nasm
org 0x401000
jmp_here:
    db 0xE9
    dd 0x401010 - ($ + 4)  ; $表示当前位置，+4是跳过偏移字段
```

---

## 🔚 结论

| 观察点    | JMP后面写的是什么  | 编译原理        |
| ------ | ----------- | ----------- |
| VS反汇编  | 显示为绝对地址     | 实际存的是相对偏移   |
| 汇编源码   | 使用标签，编译器算偏移 | 不能直接写绝对地址跳转 |
| 要跳绝对地址 | 需用寄存器跳转     | 或者写机器码算偏移   |

---

# 4. 那 JMP DWORD PTR [addr]， 是取addr里的地址作为偏移还是作为绝对地址， 汇编中不能写绝对地址， 那addr里存的值，也是偏移？
非常棒的问题，说明你已经深入理解了**JMP 跳转机制的底层结构**。我们来详细回答你这句：

---

## ❓ 问题：

> `JMP DWORD PTR [addr]`
> 是把 `[addr]` 里的值当作偏移？还是当作绝对地址？
> 汇编中不能写绝对地址，那 `[addr]` 里的值也是偏移吗？

---

## ✅ 正确答案：

```asm
JMP DWORD PTR [addr]
```

🔹 **\[addr] 表示内存地址（addr 是一个绝对地址）**

🔹 **`[addr]` 里存的是“目标地址（绝对地址）”**，而**不是偏移值**！

也就是说：

> `JMP DWORD PTR [addr]` 的意思是：
> → 去内存中的 `addr` 地址里，**读出一个 4 字节值**，
> → 然后 **无条件跳转到那个值作为新的 `EIP/RIP`**。

---

## 🧠 举例说明（32位平台）：

假设：

```asm
addr = 0x500000
[0x500000] = 0x401000
```

那么这条指令：

```asm
JMP DWORD PTR [0x500000]
```

的效果是：

> 取出 0x500000 处的内容（值为 0x401000），跳转到 **0x401000**

### ✅ 跳转目标是 **绝对地址**，不是偏移。

---

## 🚫 汇编不能写“立即数绝对跳转”的误区

你提到这点很关键：

> 汇编中不能写 `JMP 0x401000`，那是不是意味着都不能用绝对地址？

不是的：

* **不能写 `JMP 0x401000` 是因为汇编语言语法不支持直接跳转到立即数地址**（没有这样的指令编码）
* 但是你可以用 **间接跳转的方式间接实现绝对跳转**，比如：

```asm
MOV EAX, 0x401000
JMP EAX              ; ✅ 绝对跳转

; 或者：

JMP DWORD PTR [addr] ; ✅ addr 中保存了目标地址（绝对地址）
```

---

## 🔍 小对比总结

| 写法                               | 跳转目标       | 类型      | 支持？ |
| -------------------------------- | ---------- | ------- | --- |
| `JMP label`                      | 相对偏移       | 编译器自动计算 | ✅   |
| `JMP 0x401000`                   | 立即数地址      | 不支持的指令  | ❌   |
| `MOV EAX, 0x401000`<br>`JMP EAX` | 寄存器值（绝对地址） | 间接跳转    | ✅   |
| `JMP DWORD PTR [addr]`           | 从内存读出的地址   | 间接跳转    | ✅   |

---

## 📌 总结重点

> `JMP DWORD PTR [addr]` 语义为：
> **跳转到内存中 `addr` 所保存的值（即绝对地址）**。

* 它是“间接绝对跳转”方式之一。
* 并不是偏移量！你不能把 `[addr]` 的值理解为相对位置。
* 在 PE 文件中，这种跳转方式广泛用于 IAT（导入地址表）跳转，比如 `JMP DWORD PTR [GetProcAddress]`

---

# 5. 你上面说到立即数， 汇编里不能写立即数， 那可以把立即数存在一个变量里， 如EAX, 再用jmp eax能实现绝对地址跳转？
✅ **是的，你说的完全正确！**

---

## ✅ 回答简明版：

> 汇编中确实**不能直接写立即数跳转**（如 `JMP 0x401000` 是不合法的），  
> **但可以将这个立即数加载到寄存器里，然后 `JMP` 到这个寄存器，来实现绝对地址跳转。**

---

## ✅ 示例：用 `JMP EAX` 实现绝对跳转

```asm
MOV EAX, 0x401000    ; 把目标地址放入寄存器
JMP EAX              ; 跳转到这个地址（绝对跳转）
```

这个过程实际就是：

1. `MOV EAX, 0x401000` → 把**立即数地址**存入寄存器；
2. `JMP EAX` → 无条件跳转到寄存器指向的地址。

💡 这种方式就成功绕过了不能 `JMP 立即数` 的限制！

---

## ❌ 为什么不能写 `JMP 0x401000`？

因为 Intel 指令集根本**没有这样的指令编码（opcode）**：

- `JMP` 指令支持：
  - `JMP rel8 / rel32`（相对偏移跳转）
  - `JMP reg`（寄存器跳转）
  - `JMP m32`（内存跳转）
- 但没有 `JMP imm32`（立即数跳转）这种形式！

---

## 🔄 所以常见绝对跳转的合法写法有 3 种：

| 写法 | 意义 | 是否支持 |
|------|------|----------|
| `JMP 0x401000` | 立即数地址跳转 | ❌ |
| `MOV EAX, 0x401000`<br>`JMP EAX` | 通过寄存器跳转到绝对地址 | ✅ |
| `JMP DWORD PTR [addr]` | 通过内存中保存的地址跳转 | ✅ |

---

## 🧪 C++ + 汇编混合示例（Visual Studio）

你可以在 VS 中写：

```cpp
void func() {
    MessageBoxA(0, "Hi", "Jump!", 0);
}

int main() {
    __asm {
        MOV EAX, OFFSET func   ; 把 func 的地址放入 EAX
        JMP EAX                ; 跳转到 func 执行
    }
    return 0;
}
```

🔹 上面 `OFFSET func` 是立即数，汇编里不能直接 `JMP OFFSET func`，但放入寄存器后再跳转就可以了。

---

## ✅ 总结一句话：

> 汇编不能 `JMP imm32`，但你可以 `MOV imm32 → 寄存器`，再 `JMP 寄存器`，一样能完成**绝对跳转**！

---

# 6.为什么上面代码要加offset,不能写move eax, func吗， 为什么加offset ?
非常好的问题！你问的是：

> 为什么不能直接写 `MOV EAX, func`，而要写成 `MOV EAX, OFFSET func`？

---

## ✅ 简短回答：

| 写法                     | 含义                                    | 是否允许       |
| ---------------------- | ------------------------------------- | ---------- |
| `MOV EAX, func`        | 把 **`func` 所指的数据内容`（*func）`** 加载到 EAX | ❌ 错误（语义不符） |
| `MOV EAX, OFFSET func` | 把 `func` 的地址（函数地址）放入 EAX              | ✅ 正确写法     |

---

## 🧠 全面解释：

### 📌 `OFFSET` 是什么意思？

* 在汇编中，`OFFSET func` 表示 **获取符号 `func` 的地址（即它的地址值）**。
* 它返回的是一个立即数地址（即函数 `func` 的地址）。

### 👎 `MOV EAX, func` 是什么意思？

* 编译器会把 `func` 解释为“一个标签”或“变量名”，但没有明确是要取值还是取地址。
* 所以写 `MOV EAX, func` 是模糊/语义不清，编译器可能会报错或做错误的事情（如去读`func`的内容）。

---

## ✅ 正确的等价：

```asm
MOV EAX, OFFSET func  ; ✅ 取地址 → 0x00401000（例如）
MOV EAX, func         ; ❌ 试图取内容 → 错误或语义错误
```

---

## 🔍 举个类比（变量更明显）

假设：

```c
int value = 123;
```

然后你写：

```asm
MOV EAX, value        ; 表示：读取变量 value 中的内容（123）
MOV EAX, OFFSET value ; 表示：获取变量 value 所在的内存地址
```

🧠 所以：

| 语法                      | 结果                                   |
| ----------------------- | ------------------------------------ |
| `MOV EAX, value`        | 把内存中 `value` 的值取出来（123）              |
| `MOV EAX, OFFSET value` | 把 `value` 所在内存地址（如 0x00403000）放入 EAX |

---

## 🔁 回到你原来的问题：

```cpp
MOV EAX, OFFSET func   ; ✅ 正确：将函数地址存入 EAX
MOV EAX, func          ; ❌ 错误或不明确：语义上是“取函数的内容”，编译器不接受
```

因为你要跳转到函数入口地址，所以必须要用 `OFFSET`。

---

## ✅ 结论：

> `OFFSET func` 明确告诉编译器：“我要这个函数的地址”。
> `func` 单独使用不带 `OFFSET`，在 `MOV` 指令中是不明确的，会导致语法或语义错误。

---

# 7. 关于offset与lea
✅ **大多数情况下，是的 —— 在汇编语言里你想**“取地址”**，就应该显式地使用 `OFFSET`。**

但也要分场景说明，有些地方**编译器可以自动推导地址**，而有些地方必须**手动写 `OFFSET`** 才行。

---

## ✅ 一、什么时候必须用 `OFFSET`？

| 用途 | 示例 | 说明 |
|------|------|------|
| 将变量地址放入寄存器 | `MOV EAX, OFFSET var` | 明确告诉汇编器：“我要地址” |
| 函数地址跳转 | `MOV EAX, OFFSET func` | 获取函数入口地址 |
| 配合 `PUSH` | `PUSH OFFSET str` | 把地址压栈，而不是内容 |
| 定义表项 | `dd OFFSET handler1` | 在 jump table 中保存地址 |

---

## ❌ 如果你直接写 `MOV EAX, var`，编译器会认为你是想：

```nasm
MOV EAX, DWORD PTR [var]   ; 从内存读取内容
```

这是“取值”而不是“取地址”。

---

## ✅ 二、什么时候可以不用 `OFFSET`？

某些编译器（如 C 中的 inline asm）或伪指令中**可以推导地址**：

```cpp
int val = 123;

__asm {
    lea eax, val     ; ✅ 这也是“取地址”，不需要 OFFSET
}
```

- `LEA`（Load Effective Address）能获取变量地址，常用于代替 `MOV EAX, OFFSET xxx`
- 它在功能上类似于 `OFFSET`，但是汇编指令，不是编译器关键字

---

## 🧪 比较 `OFFSET` 和 `LEA`

| 写法 | 结果 | 是否汇编指令 | 是否常用于取地址 |
|------|------|----------------|------------------|
| `MOV EAX, OFFSET var` | 把地址放入 EAX | ❌（伪操作） | ✅ |
| `LEA EAX, var`        | 把地址放入 EAX | ✅（真指令） | ✅ |
| `MOV EAX, var`        | 把值放入 EAX | ✅（从内存读） | ❌ |

---

## 📌 小结：你只要记住一句话

> 👉 **取地址就加 `OFFSET`，或者用 `LEA`。**
>
> **不加 `OFFSET` 就是“取值”，而不是“取地址”。**

---

## ✅ 实用口诀

```
MOV EAX, var       ; 是取值（等于 [var]）
MOV EAX, OFFSET var; 是取地址
LEA EAX, var       ; 是取地址（有效地址加载）
```

---

# 8. 那我上面不是可以写成lea eax, func之后call eax?
💯 **完全正确！你说得非常棒！**

是的，你完全可以写成：

```asm
LEA EAX, func   ; 取函数 func 的地址
CALL EAX        ; 调用该地址的函数
```

---

## ✅ 说明：

* `LEA EAX, func`：加载 `func` 的地址（和 `MOV EAX, OFFSET func` 等价）
* `CALL EAX`：间接调用地址中存的函数，相当于 `CALL [EAX]`，就是跳转并保存返回地址

---

## 🔍 `LEA` vs `OFFSET` 回顾一下：

| 写法                     | 类型     | 效果                 |
| ---------------------- | ------ | ------------------ |
| `MOV EAX, OFFSET func` | 编译器伪操作 | 直接取地址放进寄存器         |
| `LEA EAX, func`        | 汇编指令   | 取地址（有效地址加载）放入寄存器   |
| `CALL EAX`             | 汇编指令   | 跳转到寄存器 EAX 指向的函数地址 |

---

## ✅ 为什么 `LEA` 能代替 `OFFSET`？

因为 `LEA`（Load Effective Address）是专门用来获取变量或标签的地址的，它从符号中解析出地址，不会访问内存。

它和 `MOV EAX, [func]` 完全不同：

| 指令                | 含义                      |
| ----------------- | ----------------------- |
| `LEA EAX, func`   | 把 `func` 的地址放入 EAX      |
| `MOV EAX, func`   | 读取 `func` 指向的内存内容（错误用法） |
| `MOV EAX, [func]` | 从地址 `func` 取值           |

---

## 🧪 示例：完整调用过程

```cpp
#include <Windows.h>

void func() {
    MessageBoxA(0, "Hi", "LEA + CALL EAX", 0);
}

int main() {
    __asm {
        LEA EAX, func   ; 等价于 MOV EAX, OFFSET func
        CALL EAX        ; 跳转并压栈返回地址
    }
    return 0;
}
```

效果等同于：

```cpp
func();
```

---

## 🧠 小结

| 你想做的事    | 推荐写法                                     |
| -------- | ---------------------------------------- |
| 获取函数地址   | `LEA EAX, func` 或 `MOV EAX, OFFSET func` |
| 调用某地址的函数 | `CALL EAX`                               |
| 跳转到某地址执行 | `JMP EAX`                                |

---


# 最后，关于修改入口点（EOP）前5字节跳转Shellcode后，原指令处理总结
当然，以下是针对“修改入口点前5字节跳转shellcode，执行后如何处理原5字节指令”的总结，带问答形式，方便你归档和复习：

---

# 修改入口点（EOP）前5字节跳转Shellcode后，原指令处理总结

---

## 问题一：

**修改入口点的前5字节写跳转指令跳转到shellcode，会影响原程序吗？**

### 答：

会的。
前5字节原本是程序的第一条或几条指令，改成跳转指令后，这部分代码被覆盖丢失，程序原指令逻辑被破坏。

---

## 问题二：

**如何保证程序继续正常执行，避免丢失原入口处指令？**

### 答：

必须**保存这5字节原指令**，并在shellcode中执行这5字节指令，执行完后再跳转回原入口点后续代码（入口+5字节处），保证程序流程完整。

---

## 问题三：

**执行顺序是怎样的？**

### 答：

1. 修改入口点前5字节写跳转指令，跳转到shellcode。
2. shellcode执行自己的逻辑。
3. shellcode执行被覆盖的5字节原指令。
4. shellcode跳转回入口点后5字节处，继续执行剩余程序。

---

## 问题四：

**能不能先执行这5字节指令，再执行shellcode？**

### 答：

一般不建议，因为入口点代码已被修改，跳转指令替换了原始指令，CPU无法执行入口点原指令，除非做额外操作保存和恢复。

通常做法是先跳转到shellcode，shellcode执行逻辑后补执行原指令。

---

## 问题五：

**修改入口点跳转shellcode，shellcode结束后是否需要跳回？**

### 答：

视需求而定。

* 如果你想程序正常运行，**必须跳回入口点后续地址继续执行**。
* 如果shellcode完全替代程序流程（例如加载器、壳），可以不跳回。

---

## 总结流程示意：

```asm
; 原入口前5字节被改成
E8 xx xx xx xx       ; 跳转shellcode

; shellcode开始：
; 执行自定义逻辑

; 执行被覆盖的5字节原指令

; 跳转回原入口 + 5 继续执行程序
JMP 原入口+5
```

---

# 原来的EOP地址里的5字节何时执行?
你的理解也完全有道理！其实两种方式都可以，但“放在shellcode开头先执行原EOP5字节指令”和“shellcode执行完后再执行原EOP5字节指令”，各有优缺点：

---

# 1. 放在 shellcode 开头先执行原入口被覆盖的 5 字节指令

**优点：**

- 确保程序环境（寄存器、栈等）和预期流程尽量不变，减少意外行为。  
- 原代码先执行，符合程序的正常逻辑执行顺序。  
- 方便在之后安全地执行你自己的shellcode逻辑。  

**缺点：**

- 可能导致你shellcode后续依赖的寄存器状态被改变，需要保存和恢复现场。  

---

# 2. 先执行完整 shellcode，再执行原入口被覆盖的 5 字节指令

**优点：**

- 你自己的shellcode逻辑先执行，操作顺序更直观。  
- 适合shellcode想先做准备、hook等操作后再执行原入口指令。  

**缺点：**

- 先执行自己的逻辑，可能改变寄存器、内存状态，导致原入口5字节指令执行时环境和预期不一致，可能引发异常或程序错误。  
- 如果原入口5字节指令中包含控制流指令（如调用、跳转），执行顺序会更复杂。  

---

# 3. 总结建议

| 方式                      | 推荐场景               | 注意事项                         |
|--------------------------|------------------------|----------------------------------|
| shellcode开头先执行原指令  | 原代码简单，环境敏感   | 需注意保存现场，避免影响后续逻辑 |
| shellcode末尾再执行原指令  | shellcode先做准备工作 | 需确保环境一致，避免程序异常     |

---

# 4. 实际选择

- **如果原入口指令非常简单且不改变环境，放开头或末尾都可以**  
- **如果原入口指令较复杂，且依赖环境稳定，建议先执行原指令（开头）**  
- **很多真实hook和注入场景，都是先执行原指令，再执行自己的代码，或者反过来，看具体需求**

---






